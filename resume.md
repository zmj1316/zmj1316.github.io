---
layout: resume
title: Key Zhang 的简历
---

# Key Zhang

## 个人信息

* 性别： 男
* 邮箱： [zmj1316@gmail.com](mailto:zmj1316@gmail.com)
* 联系电话： `hide`
* 出生日期： 1995-04-19
* github：[https://github.com/zmj1316](https://github.com/zmj1316)
* 主页：[https://zmj1316.github.io](https://zmj1316.github.io)

## 教育经历

`2013/07 - 2017/07`

__浙江大学，计算机科学与技术，本科，GPA top 5%__

`2017/09 - 2020/03`

__浙江大学，计算机技术，硕士__


## 技能方向

### 语言

C++ > Python > JavaScript, MaxScript, Shell

### 技能

游戏开发, 图形学, 动画系统, 物理系统, 并行计算, 操作系统

### 工具

Visual Studio, VTune, RenderDoc, 3DS MAX, Docker, WinDbg, SSH


## 项目经历

### 正式项目


`2018/12 - 至今`

__超大规模 Procedural Virtual Texture 地表渲染__

* 基于 Virtual Texture 的高效大世界细节地表渲染
* 离线加载\实时生成 Atlas Page
* 基于四叉树的二级页表查找，实现超大规模（2<sup>20</sup> 级别）VT 的快速更新和索引; 参考 far cry4 的 Adaptive Procedure Virtual Texture 实现的改进方案，对 far cry 的扩容方案进行了改进，更加实用和明确
* 实现了基于 Compute Shader 的 BC1 和 BC5 格式的实时压缩
* 详细项目解释请看 [附录](#VT)


`2018/01 - 2018/04`

__物理引擎的材质系统以及美术工具链整合__

* 重新规划美术模型制作流程，增加物理模型和物理材质制作的规范
* 编写基于 FBX 格式的通用格式转换工具以实现快捷、通用的模型和材质自定义数据格式导出流程
* 为美术制作 3ds Max 的导出工具和辅助工具提高制作效率
* 在端游引擎集成物理材质系统，实现自定义数据格式的解析和物理材质的判断功能
* 详细项目解释请看 [附录](#PHYSX)


`2018/01 - 2018/10`

__荒野行动 Plus 端游引擎维护__

* IK 功能的适配
* 游戏客户端打包与发布流程优化
* 反外挂代码混淆、加壳
* 游戏引擎崩溃、卡顿与日常维护处理


`2017/06 - 2018`

__*\*端游客户端资源发布流程优化*__

* 通过增加类似持续集成的流程，将最终发布阶段的工作提前，从而分摊了工作量，减少客户端版本发布和部署所需的时间，加快测试和发布流程
* 通过 Docker 容器简化工具环境部署
* 通过 Jenkins 搭建自动化工具交互平台

性能提升：由原来 30分钟 - 2个小时 的打包发布时间，降到 2 - 30分钟 。
提升主要依赖于对整个打包流程的优化：
* 将原来基于本地文件修改时间和md5的判断增量更新方法，改为通过比较 svn 更新记录，大幅度减少磁盘 IO 的开销 （约减少 30 分钟）
* 将原先在打包时进行的贴图转换压缩过程，通过 CI 的方式在资源上传的时候提前完成，将 CPU 开销分摊到平时 （约减少 30 分钟），提前压缩还可以减少打包时从网络下载的文件大小。
* 利用 btrfs 的 COW 功能，减少生成 diff 时文件复制的 IO 和磁盘空间开销（优化3 - 10 分钟）
* 接入 Jenkins 作为用户交互前端，轻松接入各个自动化流程

* 详细项目解释请看 [附录](#PG)


`2017/03 - 2017/08`

__骨骼动画 IK 系统__

* 实现了基于 FABRIK 算法的全身动画 IK 计算模块，后续已经集成到端游引擎中
* 部分代码 [gist 链接](https://gist.github.com/zmj1316/4bec6de16d25ff9e779de27db5e96001)

`2016/09 - 2017/02`

__Unity 资源加载管理框架__

* 在打包时记录并拆分 Unity 资源间的依赖关系，减少包体冗余
* 运行时根据记录动态重建资源依赖，从而控制资源加载的内存占用

### 业余|课程项目

`2018/10 - 至今`

__GPU 粒子系统__

* 基于 D3D12 Compute Shader 实现 GPU 发射、模拟、渲染的高性能高效果的粒子系统
* 对传统 GPU 粒子的发射、模拟、绘制流程进行创新，以实现全新的视觉效果
* 尚未完成


`2018/02 - 2018/03`

__GPU based path tracer__

* 基于 D3D11 Compute Shader 实现的光线追踪 path tracer。
* 实现了 BVH 加速结构、重要性采样、轮盘等算法
* 项目地址: [https://github.com/zmj1316/path-tracer](https://github.com/zmj1316/path-tracer)

`2016/03 - 2016/05`

__课程设计 Blipay__

* 软件工程团队课程设计
* 前端基于 React，后端基于 Express
* 实时聊天基于 socket.io
* 项目地址: [https://github.com/magicae/Blipay](https://github.com/magicae/Blipay)

## 职业经历

`2019/01 - 至今`

__手游引擎开发实习生__

网易游戏雷火工作室


`2016/07 - 2018/12`


__引擎开发实习生__

网易游戏盘古工作室


<div style="page-break-after: always;"></div>

## 附录部分

<span id="VT"></span>

## Virtual Texture

###  概念

Virtual Texture 是由卡马克最先在 ID 的游戏 RAGE 中实用的，由于其突出的优势，目前在育碧旗下的各个开放世界游戏中得到了运用，最出名的包括 FarCry 和 Ghost Recon 系列。

Virtual Texture 概念和 OS 中的 Virtual Address 类似，是预先定义了一个极大的贴图地址空间，但是并不实际分配物理显存，而是通过一张 PageTable 即 页表，来将空间映射到一块实际的贴图上，而分配空间的最小单位，即为 Page 页。这样，就可以用一张相比 Virtual Texture 极小的 PageTable 来实现对整个虚拟地址空间的索引。

具体到实际的应用中，由于游戏大世界的地表需要足够的多样性和复杂度来提高真实性，往往在每帧的渲染中需要通过对大量贴图进行采样和计算才能得到结果，所以需要一个技术能将复杂计算的结果 Cache 下来，这样之后就只需要直接采样计算的结果，不需要再进行复制计算和多次采样了。

因此得到实践的方案就是，将整个大世界的地表映射到 Virtual Texture 的地址空间，根据玩家相机所在的位置，对其周围的地表区块进行预先计算，并且写入到 Virtual Texture 中对应的位置，在运行时直接采样 VT 得到结果，从而提高性能。对于离开玩家视野的区块，则根据 LRU 进行卸载，控制物理显存的占用。

而随着游戏画面的不断提高，地表的精度也不断提高，Virtual Texture 的大小也增大了几个数量级，从而使得 PageTable 的大小也水涨船高，以目标项目为例， VT 的大小是 2<sup>20</sup>，一个 Page 大小是 256X256，所以 PageTable 的大小来到了 2<sup>12</sup>，也就是 4K 的大小，这无论是对于其更新还是采样都造成了困扰，育碧为了实现更高的精度，提出了相应的解决方案（参考 far cry 4 的 Adaptive Procedure Virtual Texture）。

但是原文的实现方式过于复杂，我直接参考了 OS 上的多级页表结构，对一级页表进行了一次分页操作，实现了 Virtual Texture 的二级页表方案，逻辑更清晰，流程更简洁。

### 图例

如图所示，下面就是 Cache 在物理显存中的页表

二级页表:

![二级页表](/images/PageLevel2.jpg)

一级页表:

![一级页表](/images/PageLevel1.jpg)

物理显存贴图:

![物理贴图](/images/Atlas.jpg)



如图所示，不同颜色表示根据与相机的距离，加载的不同精度的 Page，精度越低，一块 Page 能覆盖的地表就越大，最终实现对地表贴图的高效 Cache。

![](/images/VTMips.JPG)



<div style="page-break-after: always;"></div>

<span id="VT"></span>


## 物理材质系统和工具链

### 解释

* 这个东西做来干什么的？

为了让游戏引擎能够区分一个物体不同部位的物理材质。并且让美术能以最高效率来制作相关的物理模型。

* 为什么要实现这个材质系统?

因为目前主流的商业引擎 （Unity, Unreal4） 都只支持对整个物体的物理材质进行区分，无法具体到对物体各个不同区块的区分，

这主要是由于美术在 Max Maya 等工具中，只能指定区分渲染材质，没有指定物理材质的功能，而引擎也只能接受统一材质的物理模型

而我们为了实现更真实的物理效果，需要对物理模型进行材质细分，因此我从美术制作流程开始设计（参考了 EA 美术的经验），实现了完整的物理材质制作流程，使得美术可以在 Max 中导出渲染模型和材质的同时，也能制作、导出物理模型和材质划分的自定义数据格式，并且在引擎中集成相应的解析功能。

### 效果图

如图，美术在 Max 中指定了物理模型的两个部分材质分别为 Stone 和 Chain ，工具将会识别这些标记并且转换为相应的物理数据。

![](/images/MaxTool.jpg)

<div style="page-break-after: always;"></div>


<span id="PG"></span>

## 打包工具

### 流程图

![流程图](/images/Pack.JPG)


 1  将原流程的 svn update 和 文件时间比较、md5比较 用远程的 svn diff 操作代替，直接得到增量结果，干掉了多余的 IO
 
 2  将 CPU 开销巨大的贴图转换工作，提前到平时完成，通过时间分摊了 CPU 压力，打包的时候直接下载转换完成的文件，将 CPU 开销变为网络 IO 开销 