
<div style="page-break-after: always;"></div>

## 附录部分

<span id="VT"></span>

## Virtual Texture

###  概念

Virtual Texture 是由卡马克最先在 ID 的游戏 RAGE 中实用的，由于其突出的优势，目前在育碧旗下的各个开放世界游戏中得到了运用，最出名的包括 Far Cry 和 Ghost Recon 系列。

Virtual Texture 概念和 OS 中的 Virtual Address 类似，是预先定义了一个极大的**虚拟贴图地址空间**，但是并不实际分配物理显存，而是通过一张 **PageTable** 即 页表，来将空间映射到一块实际的贴图上，而分配空间的最小单位，即为 Page 页。这样，就可以用一张相比 Virtual Texture 极小的 PageTable 来实现对整个虚拟地址空间的索引。

具体到实际的应用中，由于游戏大世界的地表需要足够的多样性和复杂度来提高真实性，往往在每帧的渲染中需要通过对大量贴图进行采样和计算才能得到结果，所以需要一个技术能将复杂计算的结果 **Cache** 下来，这样之后就只需要直接采样计算的结果，不需要再进行**重复计算**和多次采样了。

因此得到实践的方案就是，将整个大世界的地表**映射**到 Virtual Texture 的地址空间，根据玩家相机所在的位置，对其周围的地表区块进行**预先计算**，并且写入到 Virtual Texture 中对应的位置，在运行时直接采样 VT 得到结果，从而提高性能。对于离开玩家视野的区块，则根据 **LRU** 进行卸载，控制物理显存的占用。

而随着游戏画面的不断提高，地表的**精度**也不断提高，Virtual Texture 的大小也增大了几个数量级，从而使得 PageTable 的大小也水涨船高，以目标项目为例， VT 的大小是 2^20 ，一个 Page 大小是 256X256，所以 PageTable 的大小来到了 2^12 ，也就是 4KX4k 的大小，过大的页表无论是对于其更新还是采样都造成了困扰，育碧为了实现更高的精度，提出了相应的解决方案（参考 far cry 4 的 Adaptive Procedure Virtual Texture）。

但是原文的实现方式过于复杂，我直接参考了操作系统上的**多级页表**结构，对一级页表进行了一次分页操作，实现了 Virtual Texture 的**二级页表**方案，解决了页表过大的问题，逻辑更清晰，流程更简洁。

我同时还实现了 BC1 和 BC5 格式贴图的实时压缩，这样可以大幅度**减少** Cache 贴图的**显存占用**，从而能 Cache 更多 Page，提高精度。

### 图例

如图所示，下面就是 Cache 在物理显存中的页表

二级页表:

![二级页表](/images/PageLevel2.jpg)

一级页表:

![一级页表](/images/PageLevel1.jpg)

物理显存贴图:

![物理贴图](/images/Atlas.jpg)



如图所示，不同颜色表示根据与相机的距离，加载的不同精度的 Page，精度越低，一块 Page 能覆盖的地表就越大，最终实现对地表贴图的高效 Cache。

![](/images/VTMips.JPG)



<div style="page-break-after: always;"></div>

<span id="PHYSX"></span>


## 物理材质系统和工具链

### 解释

项目的目的是为了让游戏引擎能够区分一个物体**不同部位**的物理材质，并且让美术能以最高**效率**来制作相关的物理模型。

目前主流的商业引擎 （Unity, Unreal4） 都只支持对整个物体的物理材质进行区分，无法具体到对物体各个不同区块的区分，

这主要是由于美术在 Max Maya 等工具中，只能指定区分渲染材质，没有指定物理材质的功能，而引擎也只能接受统一材质的物理模型

而我们为了实现更真实的物理效果，需要对物理模型进行材质细分，因此我从美术制作流程开始设计（参考了 EA 美术的经验），实现了完整的物理材质**制作流程**，使得美术可以在 Max 中导出渲染模型和材质的同时，也能制作、导出物理模型和材质划分的**自定义数据**格式，并且在引擎中集成相应的**解析**功能。

### 效果图

如图，美术在 Max 中指定了物理模型的两个部分材质分别为 Stone 和 Chain ，工具将会识别这些标记并且转换为相应的物理数据。

![](/images/MaxTool.jpg)

<div style="page-break-after: always;"></div>


<span id="PG"></span>

## 打包工具

### 解释

性能提升：由原来 **30分钟 ~ 2个小时** 的打包发布时间，降到 **2 ~ 20分钟** 。
提升主要依赖于对整个打包流程的优化：
* 1.将原来基于本地文件修改时间和md5的判断**增量**更新方法，改为通过 **svn diff** 比较更新记录，大幅度减少磁盘 IO 的开销 （约减少 30 分钟）
* 2.将原先在打包时进行的贴图转换压缩过程，通过 CI 的方式在资源上传的时候提前完成，将 CPU 开销**分摊**到平时 （约减少 30 分钟），提前压缩还可以减少打包时从网络下载的文件大小。
* 3.利用 btrfs 的 CopyOnWrite 功能，减少生成 diff 时文件复制的 IO 和磁盘空间开销（优化 3 ~ 10 分钟）
* 4.接入 **Jenkins** 作为用户交互前端，轻松接入各个自动化流程


### 流程图

![流程图](/images/Pack.JPG)


 1  将原流程的 svn update 和 文件时间比较、md5比较 用远程的 svn diff 操作代替，直接得到增量结果，干掉了多余的 IO

 2  将 CPU 开销巨大的贴图转换工作，提前到平时完成，通过时间分摊了 CPU 压力，打包的时候直接下载转换完成的文件，将 CPU 开销变为网络 IO 开销 